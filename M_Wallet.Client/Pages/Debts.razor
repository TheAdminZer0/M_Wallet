@page "/debts"
@inject HttpClient Http
@inject IDialogService DialogService

<PageTitle>Financial Dashboard</PageTitle>

@* Financial dashboard: assets, liabilities, cash flow *@

<MudText Typo="Typo.h3" GutterBottom="true">Financial Dashboard</MudText>
<MudText Class="mb-4">Overview of assets, liabilities, and cash flow.</MudText>

@if (isLoading)
{
    <MudProgressCircular Color="Color.Primary" Indeterminate="true" />
}
else
{
    <!-- Assets & Revenue Section -->
    <MudText Typo="Typo.h5" Class="mt-4 mb-2">Assets & Revenue</MudText>
    <MudGrid>
        <MudItem xs="12" sm="6" md="3">
            <MudPaper Class="pa-4 mud-theme-primary" Elevation="3">
                <div class="d-flex justify-space-between align-center">
                    <MudText Typo="Typo.subtitle2" Class="white-text">Inventory Value (Cost)</MudText>
                    <MudIconButton Icon="@Icons.Material.Filled.History" Size="Size.Small" Class="white-text" OnClick="ShowInventoryStatement" />
                </div>
                <MudText Typo="Typo.h5" Class="white-text">@TotalInventoryValue.ToString("N2") LD</MudText>
                <MudIcon Icon="@Icons.Material.Filled.Inventory" Class="white-text float-right" Size="Size.Large" />
            </MudPaper>
        </MudItem>
        <MudItem xs="12" sm="6" md="3">
            <MudPaper Class="pa-4 mud-theme-success" Elevation="3">
                <div class="d-flex justify-space-between align-center">
                    <MudText Typo="Typo.subtitle2" Class="white-text">The Foundry</MudText>
                    <MudIconButton Icon="@Icons.Material.Filled.History" Size="Size.Small" Class="white-text" OnClick="ShowFoundryStatement" />
                </div>
                <MudText Typo="Typo.h5" Class="white-text">@TotalCashReceived.ToString("N2") LD</MudText>
                <MudText Typo="Typo.caption" Class="white-text d-block">Cost Recouped: @TotalRecoupedCost.ToString("N2") LD</MudText>
                <MudText Typo="Typo.caption" Class="white-text d-block">Net Profit: @TotalRealizedProfit.ToString("N2") LD</MudText>
                @if (TotalUnallocatedCash > 0)
                {
                    <MudText Typo="Typo.caption" Class="white-text d-block">Unallocated: @TotalUnallocatedCash.ToString("N2") LD</MudText>
                }
                <MudIcon Icon="@Icons.Material.Filled.AttachMoney" Class="white-text float-right" Size="Size.Large" Style="margin-top: -40px;" />
            </MudPaper>
        </MudItem>
        <MudItem xs="12" sm="6" md="3">
            <MudPaper Class="pa-4" Elevation="3" Style="background-color: #FF9800; color: white;">
                <MudText Typo="Typo.subtitle2" Class="white-text">Customer Debt (Receivables)</MudText>
                <MudText Typo="Typo.h5" Class="white-text">@TotalCustomerDebt.ToString("N2") LD</MudText>
                <MudIcon Icon="@Icons.Material.Filled.MoneyOff" Class="white-text float-right" Size="Size.Large" />
            </MudPaper>
        </MudItem>
        <MudItem xs="12" sm="6" md="3">
            <MudPaper Class="pa-4" Elevation="3" Style="background-color: #607D8B; color: white;">
                <MudText Typo="Typo.subtitle2" Class="white-text">Total Sales Revenue</MudText>
                <MudText Typo="Typo.h5" Class="white-text">@TotalSalesRevenue.ToString("N2") LD</MudText>
                <MudIcon Icon="@Icons.Material.Filled.TrendingUp" Class="white-text float-right" Size="Size.Large" />
            </MudPaper>
        </MudItem>
    </MudGrid>

    <!-- Liabilities Section -->
    <MudText Typo="Typo.h5" Class="mt-8 mb-2">Liabilities (Debts)</MudText>
    <MudGrid>
        <MudItem xs="12" sm="6">
            <MudPaper Class="pa-4 mud-theme-error" Elevation="3">
                <MudText Typo="Typo.subtitle2" Class="white-text">Total Supplier Debt</MudText>
                <MudText Typo="Typo.h4" Class="white-text">@TotalSupplierDebt.ToString("N2") LD</MudText>
            </MudPaper>
        </MudItem>
        <MudItem xs="12" sm="6">
            <MudPaper Class="pa-4 mud-theme-warning" Elevation="3">
                <MudText Typo="Typo.subtitle2" Class="white-text">Total Employee Debt</MudText>
                <MudText Typo="Typo.h4" Class="white-text">@TotalEmployeeDebt.ToString("N2") LD</MudText>
            </MudPaper>
        </MudItem>
    </MudGrid>

    <!-- Detailed Lists -->
    <MudGrid Class="mt-4">
        <MudItem xs="12" md="6">
            <MudCard>
                <MudCardHeader>
                    <CardHeaderContent>
                        <MudText Typo="Typo.h6">Supplier Debts (Credit)</MudText>
                    </CardHeaderContent>
                </MudCardHeader>
                <MudCardContent>
                    @if (SupplierDebts.Any())
                    {
                        <MudTable Items="@SupplierDebts" Hover="true" Dense="true" Breakpoint="Breakpoint.None">
                            <HeaderContent>
                                <MudTh>Supplier</MudTh>
                                <MudTh>Amount</MudTh>
                            </HeaderContent>
                            <RowTemplate>
                                <MudTd DataLabel="Supplier"><TruncatedText Text="@context.Key" MaxLength="20" DialogTitle="Supplier" /></MudTd>
                                <MudTd DataLabel="Amount">@context.Value.ToString("N2")</MudTd>
                            </RowTemplate>
                        </MudTable>
                    }
                    else
                    {
                        <MudText>No supplier debts.</MudText>
                    }
                </MudCardContent>
            </MudCard>
        </MudItem>

        <MudItem xs="12" md="6">
            <MudCard>
                <MudCardHeader>
                    <CardHeaderContent>
                        <MudText Typo="Typo.h6">Employee Debts (Paid by Employee)</MudText>
                    </CardHeaderContent>
                </MudCardHeader>
                <MudCardContent>
                    @if (EmployeeDebts.Any())
                    {
                        <MudTable Items="@EmployeeDebts" Hover="true" Dense="true" Breakpoint="Breakpoint.None">
                            <HeaderContent>
                                <MudTh>Employee</MudTh>
                                <MudTh>Amount</MudTh>
                            </HeaderContent>
                            <RowTemplate>
                                <MudTd DataLabel="Employee"><TruncatedText Text="@context.Key" MaxLength="20" DialogTitle="Employee" /></MudTd>
                                <MudTd DataLabel="Amount">@context.Value.ToString("N2")</MudTd>
                            </RowTemplate>
                        </MudTable>
                    }
                    else
                    {
                        <MudText>No employee debts.</MudText>
                    }
                </MudCardContent>
            </MudCard>
        </MudItem>
    </MudGrid>
    
    <!-- Cash Flow Map -->
    <MudText Typo="Typo.h5" Class="mt-8 mb-2">Cash Flow Map</MudText>
    <MudPaper Class="pa-4" Elevation="2">
        <MudText>
            <strong>Cash In:</strong> @TotalCashReceived.ToString("N2") LD (from Sales) <br/>
            <strong>Potential Cash (Debts):</strong> @TotalCustomerDebt.ToString("N2") LD (Owed by Customers) <br/>
            <strong>Inventory Assets:</strong> @TotalInventoryValue.ToString("N2") LD (Stock Value) <br/>
            <hr class="my-2"/>
            <strong>Cash Out (Liabilities):</strong> @(TotalSupplierDebt + TotalEmployeeDebt) LD (Total Debt)
        </MudText>
    </MudPaper>
}

<style>
    .white-text {
        color: white !important;
    }
    .float-right {
        float: right;
    }
</style>

@code {
    // State + fetched data sets
    private bool isLoading = true;
    private List<Purchase> purchases = new();
    private List<Product> products = new();
    private List<Transaction> transactions = new();
    private List<Payment> payments = new();

    private decimal TotalSupplierDebt => SupplierDebts.Sum(x => x.Value);
    private decimal TotalEmployeeDebt => EmployeeDebts.Sum(x => x.Value);
    
    private decimal TotalInventoryValue => products.Sum(p => p.StockQuantity * p.CostPrice);
    private decimal TotalSalesRevenue => transactions.Sum(t => t.TotalAmount);
    private decimal TotalCashReceived => payments.Sum(p => p.Amount);
    private decimal TotalCustomerDebt => transactions.Sum(t => t.TotalAmount - t.PaymentAllocations.Sum(pa => pa.Amount));

    private decimal TotalRecoupedCost;
    private decimal TotalRealizedProfit;
    private decimal TotalUnallocatedCash;

    private Dictionary<string, decimal> SupplierDebts = new();
    private Dictionary<string, decimal> EmployeeDebts = new();

    // Load purchases/products/transactions/payments then calculate metrics
    protected override async Task OnInitializedAsync()
    {
        try
        {
            var purchasesTask = Http.GetFromJsonAsync<List<Purchase>>("api/purchases");
            var productsTask = Http.GetFromJsonAsync<List<Product>>("api/products");
            var transactionsTask = Http.GetFromJsonAsync<List<Transaction>>("api/transactions");
            var paymentsTask = Http.GetFromJsonAsync<List<Payment>>("api/payments");

            await Task.WhenAll(purchasesTask, productsTask, transactionsTask, paymentsTask);

            purchases = await purchasesTask ?? new();
            products = await productsTask ?? new();
            transactions = await transactionsTask ?? new();
            payments = await paymentsTask ?? new();

            CalculateDebts();
            CalculateFoundryBreakdown();
        }
        catch (Exception ex)
        {
            // Handle error
            Console.WriteLine(ex.Message);
        }
        finally
        {
            isLoading = false;
        }
    }

    // Build supplier/employee debt summaries
    private void CalculateDebts()
    {
        SupplierDebts = purchases
            .Where(p => p.PaidBy == "Credit" && p.PaymentStatus == "Pending")
            .GroupBy(p => p.SupplierName ?? "Unknown")
            .ToDictionary(g => g.Key, g => g.Sum(p => p.TotalAmount));

        EmployeeDebts = purchases
            .Where(p => p.PaidBy != null && p.PaidBy.StartsWith("Employee: ") && p.PaymentStatus == "Paid") // Paid by employee means store owes them
            .GroupBy(p => p.PaidBy.Substring("Employee: ".Length))
            .ToDictionary(g => g.Key, g => g.Sum(p => p.TotalAmount));
    }

    // Allocate payments into cost/profit/unallocated buckets
    private void CalculateFoundryBreakdown()
    {
        TotalRecoupedCost = 0;
        TotalRealizedProfit = 0;
        TotalUnallocatedCash = 0;

        foreach (var payment in payments)
        {
            decimal allocatedAmount = 0;

            if (payment.Allocations != null)
            {
                foreach (var allocation in payment.Allocations)
                {
                    allocatedAmount += allocation.Amount;

                    // Find the transaction for this allocation
                    // Note: The allocation object from API should have the Transaction populated if we used Include properly.
                    // If not, we might need to look it up in the 'transactions' list.
                    // Based on PaymentsController, it includes Transaction and Items.
                    
                    var transaction = allocation.Transaction;
                    
                    // Fallback to lookup if navigation property is null (though controller sends it)
                    if (transaction == null)
                    {
                        transaction = transactions.FirstOrDefault(t => t.Id == allocation.TransactionId);
                    }

                    if (transaction != null && transaction.Items != null && transaction.Items.Any())
                    {
                        decimal transactionTotalRevenue = transaction.Items.Sum(i => i.Subtotal); // Or i.Quantity * i.UnitPrice
                        decimal transactionTotalCost = transaction.Items.Sum(i => i.Quantity * i.UnitCost);

                        if (transactionTotalRevenue > 0)
                        {
                            decimal costRatio = transactionTotalCost / transactionTotalRevenue;
                            // Clamp ratio to 1 (in case cost > revenue, i.e., loss)
                            // If loss, then all payment goes to cost recoup until cost is met? 
                            // Or just proportional?
                            // Let's stick to proportional for now. If I sold for 100 (Cost 120), and got paid 50.
                            // Cost Ratio = 1.2. 
                            // Recouped = 50 * 1.2 = 60? No, can't recoup more than paid.
                            // If Cost > Revenue, then Profit is negative.
                            // Realized Profit = 50 * (1 - 1.2) = -10.
                            // Recouped Cost = 60.
                            // Net = 50. Correct.
                            
                            TotalRecoupedCost += allocation.Amount * costRatio;
                            TotalRealizedProfit += allocation.Amount * (1 - costRatio);
                        }
                        else
                        {
                            // Revenue is 0. Weird case. Treat as profit? Or unallocated?
                            // If revenue is 0, we can't divide.
                            TotalUnallocatedCash += allocation.Amount;
                        }
                    }
                    else
                    {
                        // Transaction not found or has no items
                        TotalUnallocatedCash += allocation.Amount;
                    }
                }
            }

            // Add any unallocated amount from this payment
            if (payment.Amount > allocatedAmount)
            {
                TotalUnallocatedCash += (payment.Amount - allocatedAmount);
            }
        }
    }

    // Statement for cash inflow/outflow (Foundry)
    private async Task ShowFoundryStatement()
    {
        var items = new List<StatementItem>();
        
        // Inflow: Payments
        items.AddRange(payments.Select(p => new StatementItem 
        { 
            Date = p.PaymentDate, 
            Description = $"Payment Received ({p.PaymentMethod}) - {p.Reference}", 
            Amount = p.Amount 
        }));

        // Outflow: Purchases paid by Store
        items.AddRange(purchases
            .Where(p => p.PaymentStatus == "Paid" && (p.PaidBy == "Store" || string.IsNullOrEmpty(p.PaidBy)))
            .Select(p => new StatementItem 
            { 
                Date = p.PurchaseDate, 
                Description = $"Purchase - {p.SupplierName}", 
                Amount = -p.TotalAmount 
            }));

        await ShowStatement("The Foundry Statement", items);
    }

    // Statement for inventory value movement
    private async Task ShowInventoryStatement()
    {
        var items = new List<StatementItem>();

        // Inflow: Purchases (Stock In)
        items.AddRange(purchases.Select(p => new StatementItem 
        { 
            Date = p.PurchaseDate, 
            Description = $"Stock In - {p.SupplierName}", 
            Amount = p.TotalAmount // Assuming Cost Value
        }));

        // Outflow: Sales (Stock Out)
        foreach(var t in transactions)
        {
            // Calculate total cost of items in transaction
            var cost = t.Items.Sum(i => i.Quantity * i.UnitCost);
            if (cost > 0)
            {
                items.Add(new StatementItem
                {
                    Date = t.TransactionDate,
                    Description = $"Sale #{t.Id}",
                    Amount = -cost
                });
            }
        }

        // Reconciliation: Add adjustment for manual stock changes, price updates, or initial stock
        decimal ledgerBalance = items.Sum(i => i.Amount);
        decimal actualInventoryValue = TotalInventoryValue;
        decimal discrepancy = actualInventoryValue - ledgerBalance;

        if (discrepancy != 0)
        {
            items.Add(new StatementItem
            {
                Date = DateTime.Now,
                Description = "Manual Adjustments / Unrecorded Stock",
                Amount = discrepancy
            });
        }

        await ShowStatement("Inventory Value Statement", items);
    }

    // Helper to show statement dialog with running balance
    private async Task ShowStatement(string title, List<StatementItem> items)
    {
        items = items.OrderBy(i => i.Date).ToList();
        
        decimal balance = 0;
        foreach(var item in items)
        {
            balance += item.Amount;
            item.RunningBalance = balance;
        }
        
        var parameters = new DialogParameters();
        parameters.Add("Items", items.OrderByDescending(i => i.Date).ToList());
        parameters.Add("Title", title);

        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Medium, FullWidth = true };

        await DialogService.ShowAsync<FinancialStatementDialog>(title, parameters, options);
    }
}
